
第二十四届中国机器人及人工智能大赛

智能驾驶比赛项目

技 术 报 告             


目录
第 1 章 方案概述	1
第 2 章 问题描述	3
第 3 章 技术方案	12
第 4 章 方案实现	17
第 5 章 测试分析	22
第 6 章 作品总结	24
参考文献	24

第 1 章 方案概述

1.1 技术路线

利用智能车搭载的编码器、激光雷达、惯导等传感器，结合软件的开发，和上位机的调度等方式，使得小车能够具备自动建图、避障和导航的功能[1]。能够在较大范围的地图下，通过路径规划算法，控制小车以最短，最快的路径到达目标点。同时，可以应对复杂的周围情况。例如赛道折弯和 U 型弯以及障碍物等，要能够做到精准规划路径，对于障碍物要能够及时调整路径进行避障。同时，小车要将里程计，雷达数据，实时传送到上位机，这样可以随时监视小车的运动状态。上位机也可以发送指令，控制小车。例如，启动命令和紧急终止命令。整个智能车控制系统的实现大致可分为两个阶段：
①比赛场地建图阶段：使用 cartographer 以及非常实用的 gazebo 三维仿真软件和 rviz 可视化软件。通过 gazebo 构建的小车模型和三维仿真环境，根据小车搭配的配件，能够对应修改相关配置参数。应用 SLAM 技术，建立二维栅格化地图。
②路径规划与导航阶段：我们使用上位机发送开始命令，让智能车开始规划路径。并且用 CBS 算法代替常规的 A*算法，能更快解决路径冲突问题，避免小车发生碰撞。并对小车采用合并策略，提高小车对于路径计算的速度，减少反应时间。在此期间，若是智能车出现失控乱撞的情况，使用上位机发送终止命令， 停止小车。

1.2 技术难点与创新点

1.2.1 路径规划部分

技术难点：
①对于复杂的地形，路径规划的运算量大幅增加（求解时间变长），系统的运行会滞后。
②大多数关于优化解决最短路径的工作都是单一对象的优化，该项目需实现
“联合优化”[2]，对多辆小车一起进行规划最短路径。
③求解多智能车寻径的算法可分为两类:最优解和次优解。但求最优解的计算量相对于求次优解的计算量呈指数增长，使用人们通常使用次最优解。但在这种情况下，解是不唯一的，通常很难保证给定的解决方案在当前情况是最优的。
创新点：
①使用 CBS 算法替代 A*搜索算法，可以更快的排除冲突的解决方案，实现小车相互避让。
②我们实现了以下合并策略。两个智能车 ai, aj 合并成一个 meta-agent {i,
j}，并记录冲突的次数，这样做能显著的提升速度。

1.2.2 Slam 部分

技术难点：
①需要根据智能小车搭载的不同的设备和需要的数据，对 launch 文件和 lua 文件进行相应的配置。
②Gazebo 仿真环境难以完全反应真实世界。
创新点：
①通过 gazebo 的大量的仿真模型，可以在电脑上对小车建图效果进行仿真， 从而避免缺少硬件的麻烦。

1.3 测试效果
测试结果表明，当我们通过上位机发送开始命令后，智能车可以在没有人为干预的情况下，从起点区域出发，根据构建好的地图自主导航，沿着比赛赛道无碰撞前进，并且自主避障绕过锥桶障碍物，最终停止在终点区域。


第 2 章 问题描述

2.1 关键性问题以及相关研究

•slam 建图与 lunch 文件的理解以及编写

模型车辆要完成从规定起点发车、到终点停车的任务，需有一个全局先验地图为模型车辆提供大致的行驶方向。因此如何快速建立精准的先验地图，为全局路径规划提供服务成为本方案的一个关键性问题（ 即 SLAM 问题）[3] 。SLAM (simultaneous localization and mapping), 也称为 CML (Concurrent Mapping and Localization), 即时定位与地图构建，或并发建图与定位。问题可以描述为：将一个机器人放入未知环境中的未知位置，是否有办法让机器人一边移动一边逐步描绘出此环境完全的地图（所谓完全的地图（a consistent map）是指不受障碍行进到房间可进入的每个角落）。常用的 SLAM 算法有：HectorSLAM，Gmapping，cartographer 等，相比于 Hector SLAM，Gmapping 的鲁棒性更高且对激光雷达频率要求更低（Hector在机器人快速转向时很容易发生错误匹配， 建出的地图发生错位，原因主要是优化算法容易陷入局部最小值）；而相比于Cartographer，Gmapping 在构建小场景地图时不需要太多的粒子[4]并且没有回环检测，因此计算量小于 Cartographer，但精度并没有差太多。考虑到激光雷达采样频率较低（10Hz），需构建地图的场景较小，赛道地面较为平坦、环境较为单一，本方案选择计算量较小且精度较高的 Gmapping 算法。
以发布器与订阅器章节的 talker 和 listener 节点为例，说明如何编写launch 文件。
1、在 test_pkg 目录下新建 bringup 目录
2、进入 bringup, 新建 talker-and-listener.launch

3、输入代码:
4、运行 launch 文件




•TF 坐标变换以及方法解析

变换树定义了不同坐标系之间的偏移。例如，他有可移动的基座和位于基座上方的激光雷达，那么对于这台机器人，一个坐标系原定位于机器人基座中心， 另一个坐标系原点位于激光雷达传感器中心。将位于基座上的坐标系定义为
base_link，位于激光雷达上的坐标系定义为 base_laser。如下图所示：激光雷达到前方物体距离为 0.3m，而机器人的中心是在基座的中心，所以我们就需要利用 tf 来实现两个坐标之间的关系变换。



图 2.1 TF 坐标示意图
如图 2.1 所得，激光雷达位于基座中心前方 0.1m 且上方 0.2m 位置。因此可以获取到 base_link 和 base_laser 的变换关系，base_link 到 base_laser 坐标必须平移（x:0.1m,y:0.0m,z:0.2m）。由于机器人在控制时是以 base_link 为基准的，所以要根据两者的关系进行坐标转换。变换过程只需要将两者的位置关系告知 tf,由 tf 软件包完成其余工作。
为了在上述例子中使用 tf 软件包进行坐标变换，需要创建 2 个节点，分别对应于 base_link 和 base_laser 坐标系并确定那一个是父节点，哪一个是子节点。需要注意的是，tf 假设的所有变换都是由父节点到子节点的。我们假设
base_link 为 父 节 点 ， 因 此 base_link 和 base_laser 之 间 的 变 换 矩 阵 是
（x:0.1m,y:0.0m,z:0.2m）,如图 2.2 所示，通过变换，将激光雷达数据转换到base_link 坐标系下，机器人就可以利用此信息来实现避障了。

图 2.2 坐标计算示意图

•运动学控制与建模

得到传感器信息并规划出合理路径后，还需要合适的控制算法保证车辆按照规划路径运行，最终到达终点。常见控制算法有：PID 算法，纯跟踪算法，模型预测控制，神经网络，模糊控制。其中，由于工程具有一定程度计算量，控制输出与控制响应具有时间差，纯跟踪算法无法满足竞速需求。而模型预测控制与神经网络对模型要求较高，因此本方案在 PID 算法与模糊控制间进行了对比选择。经过实际测试，PID 算法可以满足控制需求，相对于模糊控制[5]，PID 具有简单易行的特点，参数也易于调整，最终本方案选择 PID 控制算法进行车模控制。
运动学模型分为正运动学模型和逆运动学模型，以移动底盘为主体分析一下两个模型：
（1）逆运动学模型（图 2.3）：根据运动规划的线速度 X，Y，角速度 Z，得出三轮全向轮各个轮子的线速度，这是移动底盘所需要得到的数据，由于 ROS 给底盘发送的是 geometry_msgs/Twist 的消息格式，并不是直接发送三个轮子每个轮子的速度，所以我们需要根据正向运动学模型方程来求解出三个轮子的速度。



图 2.3 逆运动学求解
（2）正运动学模型（图 2.4）：根据三个轮子各个的运动速度，我们可以合成移动底盘整体的运动线速度 X，Y，角速度θ；主要的应用是在使用测程法
（odometry）时，我们需要测量每个轮子的编码器脉冲数来计算轮子的转速，最终得到三个轮子线速度，根据逆运动学模型方程求解出移动底盘整体的线速度X，Y，角速度 Z。


图 2.4 正运动学求解

2.2 相关算法以及算法优化方案

•全局路径规划中 A*算法的使用

全局路径规划器使用了 A* 方法，A*算法是一种高效的路径搜索算法，采用启发函数来估计地图上机器人当前的位置到目标位置之间的距离，并以此选择最优的方向进行搜索， 如果失败会选择其他路径继续搜索直到得到最优路径。

•局部路径规划中的相关算法

局部路径实时规划是利用 base_local_planner 包实现的，该包使用 DWA
（DynamicWindow approaches，规划推理和动态窗口）算法，计算机器人每个周期内应该行驶的速度和角度（dx，dy，dtheta velocities）。DWA 算法中先离散采样机器人控制空间（dx,dy,dtheta），再对于每个采样速度，从机器人当前的状态，进行模拟预测，如果采样速度应用于一段时间内，将会出现什么情况， 然后用合并一些特征的度量标准来，从模拟预测中， 评价每个轨迹结果，如障碍物接近目标，接近全局路径和速度。舍弃不合适的路径（有障碍物碰撞的） 最后挑选得分最高的轨迹，并且发布相关的速度给移动平台。

•Costmap 代价地图算法原理解析

机器人的位置是根据从编码器和惯性传感器（IMU 传感器）获得的测位来估计的。然后，通过安装在机器人上的距离传感器来计算机器人与障碍物之间的距离。导航系统将机器人位置、传感器姿态、障碍物信息和作为 SLAM 地图的结果而获得的占用网格地图调用到固定地图（static map），用作占用区域（occupied
area）、自由区域（free area）和未知区域（unknown area）。
在导航中，基于上述四种因素，计算障碍物区域[6]、预计会和障碍物碰撞的区域以及机器人可移动区域，这被称为成本地图（costmap）。根据导航类型，成本地图又被分成两部分。一个是 global_costmap，在全局移动路径规划中以整个区域为对象建立移动计划，其输出结果就是 global_costmap。而另一个被称为 local_costmap，这是在局部移动路径规划中，在以机器人为中心的部分限定区域中规划移动路径时，或在躲避障碍物时用到的地图。然而，这两种成本图的表示方法是相同的，尽管它们的目的不同。
costmap 用 0 到 255 之间的值来表示。数值的含义如图 11-19 所示，简单地说，根据该值可以知道机器人是位于可移动区域还是位于可能与障碍物碰撞的区域。每个区域的计算取决于第 11.6 节中指定的 costmap 配置参数。
•000：机器人可以自由移动的 free area（自由区域）
•001~127：碰撞概率低的区域
•128~252：碰撞概率高的区域
•253~254：碰撞区域
•255：机器人不能移动的占用区域（occupied area） 如下所示为障碍距离与 costmap 值的关系图




图 2.5 障碍距离与 costmap 值的关系图

•逆运动学模型方程推导



图 2.6 逆运动学模型方程推导图
我们首先来进行逆运动学模型方程组推导，如图 2.6，规定 XOY 为世界坐标系，xoy 为移动底盘坐标系，Va、Vb、Vc 为全向轮线速度；La、Lb、Lc 分别为移动底盘中心到三个全向轮与地面接触点之间的距离；Vx，Vy 是移动底盘相对于车体中心的线速度；θ为移动底盘自转的角速度，逆时针为正方向；现在我们以移动底盘的某一具体位姿状态来分析，即线速度为 Vx，Vy，自转的角速度 Z

为θ（正方向运动即逆时针运动），根据三轮全向移动底盘的运动特性，平面运动速度分解合成关系，来依次分析车体三个轮子中心的速度及中心的速度的运动学模型方程。
首先，分析 A 轮的运动状态，根据逆运动学模型可知，我们需要将 Vx，Vy 速度分解到 Va 上，即可得知 A 轮的速度对整个底盘运动的作用。
如图 2.6，设 Vxa 为 Vx 在 Va 上分解后的速度，Vya 为 Vy 在 Va 上分解后的速度，Vθa 为底盘的自转角速度作用在 A 轮上的速度：
（1）分解 Vx：由于 Va 与 Vx 之间的夹角为 α，所以可得：

Vxa  =  Vx  ∗  cos a	（2-1）
（2）分解 Vy：由于 Vy 与 Va 之间的夹角如图可知 α 的位置，所以可得：

Vya  =  Vy  ∗  sin a	（2-2）
（3）由于底盘自身的角速度为 θ，那么自转引起的线速度作用在 A 轮上的速度：
Vθa  =  La  ∗ θ	（2-3）
（4）最后根据运动合成和分解可知：
Va = Vxa + Vya + Vθ a
= Vx ∗ cos a + Vy ∗ sin a + La ∗ 0	（2-4）
然后，分析 B 轮运动状态，B 轮运动情况和和 A 轮一样，同理分析：
（1）分解 Vx：由于 Vx 与 Vb 反方向之间的夹角为 α，所以：

Vxb  =   − Vx  ∗  cos a	（2-5）
（2）分解 Vy：由于 Vy 与 Va 之间的夹角如图可知α的位置，所以：
Vyb  =  Vy  ∗  sin a	（2-6）
（3）由于底盘自身的角速度为θ，那么自转引起的线速度作用在 B 轮上的速度为：
Vθb  =  Lb  ∗ θ	（2-7）
（4）最后根据运动合成和分解可知：
Vb = Vxb + Vyb + Vθ b
=− Vx ∗ cos a + Vy ∗ sin a + Lb ∗ 0	（2-8）
最后，分析 C 轮运动状态，见图 2.6，由于 Vx 与 Vc 垂直，所以 Vx 在 Vc 方向上没有分解速度，同时 Vy 与 Vc 是反方向的，那么同样我们先做假设 Vyc 为
Vy 在 Vc 上分解后的速度，Vθc 为底盘的自转角速度作用在 C 轮上的速度：
（1）分解 Vx：由于 Vx 与 Vc 垂直，所以：
Vxc  =  0	（2-9）
（2）分解 Vy：由于 Vy 与 Vc 是相反的方向，所以：
Vyc  =   − V y	（2-10）

（3）由于底盘自身的角速度为θ，那么自转引起的线速度作用在 C 轮上的速度为：
Vθc  =  Lc  ∗ θ	（2-11）
（4）最后根据运动合成和分解可知：
Vc = Vxc + Vyc + Vθ c
=− Vy  + Lc ∗ 0	（2-12）
综上可得三轮全向轮的逆运动学模型方程组为：
Va = Vx ∗ cos a + Vy ∗ sin a + La ∗ 0	（2-13）
Vb  =    − Vx ∗ cos a + Vy ∗ sin a + Lb ∗ 0	（2-14）
Vc  =    − Vy  + Lc ∗ 0	（2-15）
已知α = 30°，且 La，Lb，Lc 都是相同的长度为 L，将其带入式子 2-13， 2-14，2-15 中，可得：
Va =   3 Vt + 1 Vy + L0	（2-16）
2	2

Vb =  −  3 Vt + 1 Vy + L0	（2-17）
2	2

Vc =− Vt + L0	（2-18）

•正运动学模型方程推导

逆运动学模型方程得到后，正运动学方程就很容易了，将该方程组作为三元
一次方程组，把 Vx,Vy,θ作为未知量，把 Va,Vb,Vc 作为已知量即可，利用消元法下面来介绍求解过程：
（1）由 2-16 和 2-17 相加可得：
Va + Vb =  Vy + 2 ∗ L0	（2-19）
（2）由 2-18 和 2-19 相加可得：
Va + Vb + Vc =  3 ∗ L0	（2-20）
0 = Va + Vb + Vc
3 ∗ L




（3）将 2-21 代入到 2-19 中，可以得出 Vy:
Vy = Va + Vb − 2 ∗ Vc
3


（4）将 2-21，2-22 代入到 2-16 中可得出 Vx:

（2-21）



（2-22）

Vt =    3(Va − Vb)
3


（5）最终，2-21，2-22，2-23 就是得到的正运动学方程组：
Vt =    3(Va − Vb)
3
Vy = Va + Vb − 2 ∗ Vc
3
0  = Va + Vb + Vc
3 ∗ L



（2-23）


（2-24）
无论运动学模型方程组构建的如何精确，在实际情况下，机器人的运动通常都会存在误差，误差通常分为静态误差、动态误差和随机误差，因此对于机器人本体参数而言，轮子的半径，轮子装配的非对称性(包括电机轴线间的夹角、轮子中心距离车体中心的距离)以及运动过程中由于车体震动造成的轮子与地面间的接触面积不同所带来的不同滚动摩擦力等原因都将导致运动误差的出现，因此，建立良好的机器人运动学模型只是我们进行机器人运动控制的最基本一步， 并不是说有了正确的运动学模型方程组我们就能高枕无忧、万事大吉了，还需要多种方式完善我们的控制系统才能使其不断的接近完美，后面我们将会对机器人运动特性及其误差做进一步分析。



第 3 章 技术方案

出于快速上手小车建图与导航的目的，我们使用尽可能在现有成熟的技术方案的前提下，对其中的部分进行优化改进。整体思路如下：在建图方面，我们考虑到赛道环境比较简单，并且场地不算很大，所以采用 Gmapping 粒子滤波算法建图；在导航方面，则采用 Google 提供的 ros_navigation 导航栈进行路径规划并导航。其中的局部路径规划器使用 Teb 弹性时间带。全局规划路径使用 A*算法。
navigation 栈是 2D 的导航功能包集，通过接收里程计数据、tf 坐标变换树以及传感器数据，为移动机器人输出目标位置以及安全速度。它从里程计和传感器数据流获取信息，并将速度命令发送给移动基站（比如你的机器人）。但是， 想要在任意机器人上使用导航功能包集可能有点复杂。使用导航功能包集的先决条件是，机器人必须运行 ROS，有一个 tf 变换树，使用正确的 ROS Message types 发布传感器数据。而且，我们需要在高层为一个具有一定形状和动力学特点的机器人配置导航功能包集。

3.1 里程计和 imu 融合

robot_pose_ekf 是 ROS Navigation stack  中的一个包,通过扩展卡尔曼滤波器对 imu、里程计 odom、视觉里程计 vo  的数据进行融合,来估计平面移动机器人的真实位置姿态,输出 odom_combined 消息。robot_pose_ekf 只适用于平面上的轮式移动机器人,因此 odom 信息中的 z,pitch 和 roll 分量可以被忽略。IMU 可以提供车体坐标系相对于世界坐标系的姿态(RPY 角),其中 Roll 和 Pitch 是绝对角度,因为有重力方向作为参考,而偏航角 Yaw 则是一个相对角度。IMU 姿态的协方差矩阵代表了姿态测量的不确定度。
robot_pose_ekf 默认监听的 topic 为: imu_data 、 odom 和 vo,因此要注意发布消息时 topic 的名称要对应,否则会起不到滤波作用。不想使用默认名称的话可以用 remap 元素进行名称重映射。robot_pose_ekf.launch 文件如下:






参数说明如下:

图 3.1

freq:滤波器更新和发布频率。注意频率高仅仅意味着一段时间可以获得更多机器人位姿信息,但是并不表示可以提高位姿估计的精度。
sensor_timeout:当传感器停止向滤波器发送信息时,滤波器在没有传感器的情况下等待多长时间才重新开始工作。
odom_used, imu_used, vo_used:确认是否输入。
output_frame, base_footprint_frame:用于指定输出 tf 变换中坐标系的名字,默认为 odom_combined 和 base_footprint。
使用 rostopic list	命令可以查看 ros 中的 topic,下图中白色的
/robot_pose_ekf/odom_combined 话题就是 robot_pose_ekf 节点发布的:


图 3.2
robot_pose_ekf 在输出 odom_combined 信息同时还会发布相关的坐标变换,
输入下面指令查看 tf 变换关系，使用命令 rosrun rqt_tf_tree rqt_tf_tree 可以看出 robot_pose_ekf 节点会发布 base_footprint 坐标系相对于odom_combined 坐标系的变换:


图 3.3

参数 output_frame 和 base_footprint_frame 默认为 odom_combined 和 base_footprint,也可以根据需要在 launch 文件中进行更改,比如分别改为 odom 和 base_link,再次用 rqt_tf_tree 命令查看,如下图所示:

图 3.4

3.2 建图算法 Gmapping

我们在这里用的是 Gmapping 算法，这是目前基于激光雷达和里程计方案里面比较可靠和成熟的一个算法，在 ros 系统中有自带的节点 gmapping_slam。这个软件包位于 ros-perception 组织中的 slam_gmapping 仓库中。
但由于 gmapping 算法中需要设置的参数很多，所以往往我们会把gmapping 的启动写到 launch 文件中，同时把 gmapping 需要的一些参数也提前设置好，写进 launch 文件中。

gmapping 的作用是根据激光雷达和里程计（Odometry）的信息，对环境地图进行构建，并且对自身状态进行估计。因此它得输入应当包括激光雷达和里程计的数据，而输出应当有自身位置和地图。下面我们从消息的流向的角度来看看gmapping 算法的实际运行中的结构：


图 3.5
位于中心的是 slam_gmapping 节点，这个节点负责整个 gmapping SLAM 的工作。它的订阅需要有两个：
/tf 以及/tf_static： 坐标变换，tf2_msgs/TFMessage，其中一定得提供的有两个 tf，一个是 base_frame 与 laser_frame 之间的 tf，即机器人底盘和激光雷达之间的变换；一个是 base_frame 与 odom_frame 之间的 tf，即底盘和里程计原点之间的坐标变换。odom_frame 可以理解为里程计原点所在的坐标系。
/scan :激光雷达数据，类型为 sensor_msgs/LaserScan。
通过/tf 节点能够把周围障碍物变换到机器人坐标系下，更重要的是base_frame 与 odom_frame 之间的 tf，这个 tf 反映了里程计（电机的光电码盘、视觉里程计、IMU）的监测数据，也就是机器人里程计测得走了多少距离， 它会把这段变换发布到 odom_frame 和 laser_frame 之间。因此slam_gmapping 会从/tf 中获得机器人里程计的数据。
在实际使用的过程中，gmapping 建图对于激光数据要求比较严格，因此有些对激光吸收比较大的材料会很影响建图效果。同时里程计的偏差对于gmapping 也有显著影响，所以 gmapping 比较适合在小范围建图，例如在不大的室内。经过多次测试，我们发现在比赛场地的情况下，应用 gmapping 的建图效果精度比较高，能够很好地识别出地图边界与障碍物。

3.3 navigation 导航栈

ros navigation stack 是 ros 经典的导航包集合，在通过 gmapping 等方法得到地图后可以实现定位、全局路径规划、动态局部规划等一系列导航核心功能。下边包含 16 个 package，每个 package 完成特定的功能，共同为导航服务。如图 3.9。



图 3.7
白色的方框是导航包已经提供给我们的，灰色的是可供选择的节点，比如AMCL 和 map_server 节点，我们其实可以不需要 amcl 的定位，只靠里程计和雷达也能在较小的空间完成目标。另外一个 map 地图也不是必须的，因为导航包中， 我们可以只靠局部路径规划来完成目标点的导航。在这个框架中， global_planner 和 local_panner 是最重要的两个方面。
base_local_planner： 完成局部窗口内的路径规划任务，机器人行动速度的具体生成在此包当中完成。目前有两种局部路径规划算法实现，一是航迹推算法（TrajectoryROS），一是动态窗口法(DWA)，该包内部的默认实现是航迹推算法，但是留出了 DWA 的定义接口，DWA     的 实 现 在     dwa_local_planner   中 。global_planner：全局路径规划节点。global_planner 和后边的 navfn 的功能是一样的，实现目标点与当前点之间的全局路径规划，内部都有 Dijkstra 算法和 A*导航算法的实现，ROS 系统默认采用的是 navfn。


第 4 章 方案实现

4.1 Gmapping 建图

Gmapping 包包含 OpenSlam 的 Gmapping 的一个 ROS 封装。Gmapping 的 ROS 节点 slam_gmapping 提供基于激光的 SLAM(同时定位和创建地图)，这个节点是ros 安装包自带的，直接调用即可。依靠移动机器人收集的激光和位姿数据，使用 slam_gmapping 可以创建二维栅格地图。
首先需要安装配置环境。在这里我们选用的是 Ubuntu18.04 + ROS melodic 的环境。由于安装双系统会比较麻烦，所以对于 Ubuntu 系统的安装，我们是利用 VMware Workstation pro16 这个最新的虚拟机版本。网上有各种安装教程， 在这里不做过多的介绍。对于 ROS 系统的安装，需要在 ROS 官网找到与 ubuntu 系统对应的版本，18.04 对应于 ROS 的 melodic 版本。如果不对应的话，是安装
不上的。这里介绍几个安装的小技巧，在按照官网安装的时候，如果出现网路连接失败的提示，一个是更换镜像源，改成国内的镜像源，如果还是不行，可以试着连接手机热点，我在下载 rosinstall 文件的时候就用这种方式成功了。当然如果不需要更改 ros 里面文件，还可以使用二进制安装，如图。这样可以免去编译时的很多麻烦。

图 4.1
安装完成后。ROS 的安装目录：默认在/opt/ros 路径下。为了测试安装是否成功，我们可以先运行 roscore 命令，这是运行 ros 节点前必须打开的，为 ROS 提供名称服务+rosout+参数服务器。这样就能使两个节点通信。然后运行
启用 turtlesim 功能包下的 turtlesim_node 节点，如果成功安装 ros，会出现一只乌龟的图样。
确定安装成功以后，我们就可以将需要启动的节点以及相关的参数配置放在写在 launch 文件中，如图。

图 4.2
这是 gmapping 的 launch 文件，里面启动了 slam_gmapping 节点，同时设置了里程计坐标系，机器人坐标系，最大粒子数，雷达最远探测距离，方差，优化步长，迭代次数等许多参数，大部分是默认的配置。我只修改了坐标系名称和最远探测距离，一定要对应自己设定的名称。
在另一个终端下，输入 rviz。可以打开可视化界面，订阅其中的 map 节点。就能看到地图显示出来。再开一个终端，输入 rosrun
art_racecarracecar_teleop.py 这个脚本命令就可以用键盘控制小车。控制小车对赛道进行完整的一圈扫描，就可以构建出整个地图。
这里需要注意的是，控制小车的速度一定要很慢才行，否则由于里程计的误差，会出现很大的偏差。在环境相似的地方，gmapping 很容易将相同的一块板， 错误的构建成两块有一定距离的板。

4.2 导航

利用 Google 公司提供的开原框架，ros_navigation 可以快速对小车进行导航的配置。我们可以到 ROS 官网下载 navigation 导航栈，其下边包含 16 个package，每个 package
完成特定的功能，共同为导航服务。其中最重要的便是全局路径规划和局部路径规划。

4.2.1 全局路径规划 global_planner

全局路径规划节点。实现目标点与当前点之间的全局路径规划，内部都有Dijkstra 算法和 A*导航算法的实现。
要理解这两个算法的区别，首先从广度优先算法讲起。
正如其名称所示，广度优先搜索以广度做为优先级进行搜索。
从起点开始，首先遍历起点周围邻近的点，然后再遍历已经遍历过的点邻近的点，逐步的向外扩散，直到找到终点。
这种算法就像洪水一样向外扩张。然而现实中，我们对于每一条路的代价是不同的，所以这时候需要用 Dijkstra 算法来寻找图形中节点之间的最短路径。
考虑这样一种场景，在一些情况下，图形中相邻节点之间的移动代价并不相等。例如，游戏中的一幅图，既有平地也有山脉，那么游戏中的角色在平地和山脉中移动的速度通常是不相等的。
在 Dijkstra 算法中，需要计算每一个节点距离起点的总移动代价。同时， 还需要一个优先队列结构。对于所有待遍历的节点，放入优先队列中会按照代价进行排序。
在算法运行的过程中，每次都从优先队列中选出代价最小的作为下一个遍历的节点。直到到达终点为止。这样我们就能获得一条代价的最小的最短路径。
但是在一些情况下，如果我们可以预先计算出每个节点到终点的距离，则我们可以利用这个信息更快的到达终点。

其原理也很简单。与 Dijkstra 算法类似，我们也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取到终点移动代价最小
（离终点最近）的节点作为下一个遍历的节点。这种算法称之为最佳优先（Best
First）算法。这样做可以大大加快路径的搜索速度。
但是最佳优先算法有一个很大的问题。如果起点和终点之间存在障碍物，则最佳优先算法找到的很可能不是最短路径。在实际情况中，起点和终点必定会有障碍物，所以综合考虑下，需要将两种算法结合。这就产生例如 A*算法。
A*算法通过下面这个函数来计算每个节点的优先级。


f(n)是节点 n 的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。g(n) 是节点 n 距离起点的代价。h(n) 是节点 n 距离终点的预计代价，这也就是 A*算法的启发函数。
虽然 A*算法综合了广度优先和最佳优先的优点，在最佳路径和时间最短方面取得了很好的平衡。然而在实际使用的过程中，我们发现，将启发函数 h(n)设置得非常小，甚至于等于 0，即退化为 Dijkstra 算法时，虽然消耗较多的算力， 不过在比赛场地这种较小的地图上，并不会带来很大的影响，因为，最短的路径能够使小车运行的更加快，缩短了时间。同时在使用过程中，全局路径规划由于找最短路径的原则，规划的路径轨迹是贴着膨胀层边缘的。但是机器人是有一定的大小的，在跟随全局路径的过程中，十分容易发生碰撞现象。于是我们找到
Dijksra 的源码，在 cpp 文件中，找到函数 updateCell，



添加如下代码，

图 4.3


 	

图 4.4

判断每一个像素点的前后左后两个以内的像素点如果碰到膨胀层，则返回空值。即不将此点列入路径规划之中。通过这种方式，可以让全局路劲规划的线路更加顺滑并且减少机器人的调整时间。

4.2.2 局部路径规划 local_planner

在动态窗口法主要是在速度(v,w)空间中在得到多组轨迹以后，对这些轨迹进行评价，选取最优轨运动模型。其中，两迹所对应的的速度来驱动机器人运动。它的特点是依据移动机器人的加减速性能限定速度采样空间在一个可行的动态 范围内。
在动态窗口算法中，要模拟机器人的轨迹，所以需要有机器人的运动模型。然而，在 DWA 算法中，由于假设机器人是全向的或者是能做到原地旋转的差分机器人。当机器人运动到无法通过的路径时，就可以调用 recovery 包的中的函数， 进行恢复，寻找下一条合适的路径。然而，对于阿克曼模型的小车来说，这是非常不利的。因为小车不能进行原地旋转，所以面对当面对障碍同时又无法后退的时候，小车便会直接卡死，无法行动。为了更好的适应复杂的路况，同时应对竞赛以竞速为目的，所以在这里使用更为保险的 Teb 局部路径算法。
“TEB”全称 Time Elastic Band（时间弹性带），该方法针对全局路径规划器生成的初始轨迹进行后续修正(modification)，从而优化机器人的运动轨迹， 属于局部路径规划。“TEB”大多数目标都是局部的，只与一小部分参数相关， 因为它们只依赖于几个连续的机器人状态。这种局部结构产生了一个稀疏的系统矩阵，使得它可以使用快速高效的优化技术，
优化的结果并非一定满足约束，即实际都是软约束条件，若参数设置不合理或环境过于苛刻，teb 都有可能失败，规划出非常奇怪的轨迹。所以在 teb 算法中包含有冲突检测的部分，在生成轨迹之后逐点判断轨迹上的点是否与障碍物冲突，并且此过程考虑机器人的实际轮廓。
将 DWA 替换成 Teb 的方式也非常简单，ros 官网已经提供了相应的代码包， 我们只需要将 Teb 包拷贝到工作空间下，然后对源码包进行单独编译。

这样便可以完成 Teb 包的 plugin 的注册及插入。由于采用了 Teb 路径规划， 小车能够在导航的过程中，适时调整自己的方向，尽可能以最快的速度到达目标点。Teb 最大的好处就是能够在遇到障碍物的时候，使小车能够通过后退来重新规划路径，使得小车的灵活性大大提高，也能够适应许多狭窄的道路。在 Teb 的参数中，还能够对后退的权重，后退距离等一系列参数进行设定，使小车的鲁棒性大大提高。同时我们也发现了一些问题，当小车的 dt_ref 参数设置较小的时候，由于小车需要调整的姿态偏小，小车摆头现象明显，严重时可能会损坏舵机。同时如果局部路径目标点设置错误，导致小车并不会严格按照全局路径寻迹， 直接贯穿地图。除此以外还有许多因素影响着小车的导航性能。因此，在不同的场景下，需要对小车参数进行调试，以取得一个最平衡的状态。

第 5 章 测试分析


5.1 全局路径规划

Global_local_planner 默认使用的是 Dijkstra 算法，我们可以修改 lua 文件，将其换成 A*算法。这两者之间有比较明显的区别。Dijkstra 算法可以称作是考虑节点移动代价差异的广度优先搜索。保证当前节点的值对于前面的层一定是最优的（不管后面有啥只往前看），所以最后到终点的时候，可以保证终点到前一层选一个最优的点，这样从终点到起点一直选当前最小得到的路径一定是最优的。但 Dijkstra 是一种发散式的搜索，所以空间复杂度和时间复杂度都比较高，在面对较大的栅格地图的时候，会消耗很多的算力，这也会导致路径更新的速度变慢。所以我们这里采用 A*算法，A*算法是一种启发式算法，综合了广度优先和深度优先的长处，是 Dijksta 的升级算法，其中合理设置里面的启发式函数是关键。


在极端情况下，当启发函数 h(n)始终为 0，则将由 g(n)决定节点的优先级， 此时算法就退化成了 Dijkstra 算法。
如果 h(n)始终小于等于节点 n 到终点的代价，则 A*算法保证一定能够找到最短路径。但是当 h(n)的值越小，算法将遍历越多的节点，也就导致算法越慢。
如果 h(n)完全等于节点 n 到终点的代价，则 A*算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。
如果 h(n)的值比节点 n 到终点的代价要大，则 A*算法不能保证找到最短路径，不过此时会很快。
在另外一个极端情况下，如果 h()n 相较于 g(n)大很多，则此时只有 h(n)产生效果，这也就变成了最佳优先搜索。
通过调节启发函数我们可以控制算法的速度和精确度。因为在一些情况，我们可能未必需要最短路径，而是希望能够尽快找到一个路径即可。这也是 A*算法比较灵活的地方。
5.2 局部规划路径
DWA 是动态窗口方法，Teb 是弹性时间带方法。teb 在运动过程中会调整自己的位姿朝向，当到达目标点时，通常机器人的朝向也是目标朝向而不需要旋转。
dwa 则是先到达目标坐标点，然后原地旋转到目标朝向。由于我们是两轮差速底盘的小车，并不能都进行原理旋转来调整方向，所以当我们使用 DWA 的时候，小车是无法后退的。这也就是说，如果到达一个目标点后，前面的空间不足以以最小半径转弯的话，小车就会停止。此时为了提高小车的灵活性和容错性，我们采用了 Teb 路径规划。在实际使用过程中，teb 在运动中调节朝向会使运动路径不流畅，在启动和将到达目标点时出现不必要的后退。这在一定程度上会耽误很久的时间，然而这也大大降低了小车被卡住的风险。但是我们要注意的是，后退可能会碰到障碍物，所以 teb 需要根据场景对它的参数进行调整，例如将最大后退距离和速度限制在一个比较小的值，这样不容易碰到障碍物。


第 6 章 作品总结


6.1 自我评价与总结

近些年，全球经济发展迅速，人口数量和汽车数量不断增加，而交通拥堵、交通事故、空气污染等问题也变得越来越严重。相关统计表明，全球每年因交通事故死亡人数达 130 万人，直接经济损失超过 5180 亿美元，在我国，交通事故
的死亡人数在近十年增长超过 10 倍。无人驾驶汽车的出现对解决以上问题带来了极大的希望，因为自动驾驶比人类驾驶员反应更为迅速，行驶更加稳定，也更高效，并且能够帮助无法开车的老弱病残提供更友好的乘车体验，提高他们的生活质量。无人驾驶汽车是通过传感系统感知行驶环境，自主规划行车路线，全自动控制车辆行驶到预定目标的智能车辆。随着人们对智能控制、自动化等学科不断完善和发展，作为多学科交叉领域的无人驾驶技术在近年来蓬勃发展， 逐渐成为国家科学技术发展和物质文明发展的衡量标志之一。
本技术报告主要介绍了我们参加中国机器人及人工智能大赛智能驾驶赛设计的小车方案。在官方提供的硬件设施的基础上，利用深度学习的方法学习和研究智能驾驶的相关内容与算法，实现数据采集、数据模型构建、自主弯道识别、无人驾驶验证、自动避障等多种技术融合的场景，实现小车在规定赛道的快速行驶，从而完成规定任务。我们将在今后的学习中继续改善我们的作品。

参考文献
[1]刘禹希. 基于机器视觉的智能驾驶车辆的目标识别研究[D]. 吉林大学, 2017.
[2]李建平. 面向智能驾驶的交通车辆运动预测方法研究[D]. 吉林大学, 2018.
[3]李鑫. 面向汽车智能驾驶的毫米波雷达建模与仿真研究[D]. 吉林大学, 2020.
[4]叶语同,李必军,付黎明. 智能驾驶中点云目标快速检测与跟踪[J]. 武汉大学学报(信息科学版), 2019, 44(1): 139-144, 152.
[5]任秉韬,邓伟文,白雪松,等. 面向智能驾驶测试的仿真场景构建技术综述[J]. 中国图象图形学报, 2021, 26(1): 1-12.
[6]李轩,王飞跃. 面向智能驾驶的平行视觉感知:基本概念、框架与应用[J]. 中国图象图形学报, 2021, 26(1): 67-81.
 
